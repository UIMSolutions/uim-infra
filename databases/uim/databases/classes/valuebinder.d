module uim.databases.classes.valuebinder;

import uim.databases;
@safe:

version (test_uim_databases) {
  unittest {
    writeln("-----  ", __MODULE__, "\t  -----");
  }
}

class DValueBinder : UIMObject {
  this() {
    super();
  }

  // Array containing a list of bound values to the conditions on this object
  protected Json[string] _bindings;

  // A counter of the number of parameters bound in this expression object
  protected int _bindingsCount = 0;

  /**
     * Returns all values bound to this expression object at this nesting level.
     * Subexpression bound values will not be returned with this function.
     */
  Json[string] bindings() {
    return _bindings;
  }

  // Clears any bindings that were previously registered
  void reset() {
    _bindings = null;
    _bindingsCount = 0;
  }

  // Resets the bindings count without clearing previously bound values
  void resetCount() {
    _bindingsCount = 0;
  }

  // Associates a query placeholder to a value and a type
  void bind(string placeholder, Json value, string typeName = null) {
    Json[string] map;
    map.set("value", value);
    map.set("type", typeName);
    map.set("placeholder", placeholder.subString(1));

    _bindings[placeholder] = map;
  }

  unittest {
    auto binder = ValueBinder;
    binder.bind(":ABC", Json(1), "int");
    // writeln(binder.bindings);
  }

  // Get verbose debugging data.
  override Json[string] debugInfo(string[] showKeys = null, string[] hideKeys = null) {
    auto info = super.debugInfo(showKeys, hideKeys);
    info.set("bindings", bindings().toJson);
    return info;
  }

  unittest {
    auto binder = ValueBinder;
    binder.bind(":ABC", Json(1), "int");
    // writeln(binder.debugInfo);
  }

  /**
     * Creates a unique placeholder name if the token provided does not start with ":"
     * otherwise, it will return the same string and internally increment the number
     * of placeholders generated by this object.
     */
  string placeholder(string token) {
    auto myNumber = _bindingsCount++;
    return !token.startsWith(":") && token != "?"
      ? ":%s%s".format(token, myNumber) : token;
  }

  unittest {
    auto binder = new DValueBinder;
    binder.resetCount;
    assert(binder.placeholder("abc") == ":abc0");
    assert(binder.placeholder(":abc") == ":abc");
    assert(binder.placeholder("?") == "?");
  }

  /**
     * Creates unique named placeholders for each of the passed values
     * and binds them with the specified type.
     */
  Json[string] generateManyNamed(Json[string] items, string type = null) {
    Json[string] placeholders;
    foreach (key; items.byKey) {
      string parameter = placeholder("c");
      Json[string] map;
      map.set("value", items[key].getJson("value)"));
      map.set("type", type);
      map.set("placeholder", subString(parameter, 1));
      _bindings[parameter] = map;

      placeholders.set(key, parameter);
    };

    return placeholders;
  }

  unittest {
    auto binder = new DValueBinder;
    Json item1 = Json.emptyObject;
    item1["value"] = "xyz";

    Json item2 = Json.emptyObject;
    item2["value"] = "cde";

    binder.generateManyNamed(["XYZ": item1, "CDE": item2]);
    // writeln(binder.bindings);
  }
}

auto ValueBinder() {
  return new DValueBinder;
}
